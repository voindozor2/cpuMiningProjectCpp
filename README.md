# План по дням: сборка и майнинг **raw**-блока Bitcoin (с тест-кейсами) {.md}

> Все ожидаемые значения ниже указаны **в hex** (2 символа = 1 байт).
> Пробелы/переносы строк приведены только для читабельности — в потоке это один непрерывный байтовый массив.
> Для каждого шага прописан **endianness**.

---

## День 1 — Утилита представления: `bytes → hex` !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! --- ВЫПОЛНЕНО ---- 

**Что делаем**
Реализовать ровно одну функцию: **`to_hex(bytes)`** → строка hex в нижнем регистре, без `0x`, без изменения порядка байтов.

**Endianness параметров**

| Параметр                          | Endianness             |
| --------------------------------- | ---------------------- |
| вход: байтовая последовательность | N/A (пишется как есть) |
| выход: строка hex                 | N/A                    |

**Требования**

* 2 символа на байт, `a–f` в нижнем регистре.
* Пустой ввод → пустая строка.
* Не-байты/значения вне `0..255` → ошибка.

**Тест-кейс**

1. `[]` → `""`
2. `[0x00]` → `00`
3. `[0x01,0xA0,0x00]` → `01a000`
4. `[0xff,0x10,0x2b]` → `ff102b`
5. `bytearray([0x0a,0x0b])` → `0a0b`

Подключена библиотека Boost::algorithm для hex-форматирования.
--- ВЫПОЛНЕНО ---- 

## День 2 — CompactSize (VarInt) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! --- ВЫПОЛНЕНО ---- 

Что делаем

Пишем encode_compact_size(n) с проверкой каноничности (минимальная форма). Для массивов: пишем encode_compact_size(len(data)).

Правила кодирования

0..252 → 1 байт: uint8(n)

253..65535 → FD || uint16_le(n)

65536..4294967295 → FE || uint32_le(n)

>= 2^32 (до 2^64-1) → FF || uint64_le(n)

Endianness

Поле	Порядок
префикс (FD/FE/FF)	как есть
хвостовое значение	LE (little-endian)

LE16/LE32/LE64 = представить n на 2/4/8 байтах в порядке от младшего байта к старшему.

Схема (flowchart) кодирования
[Старт] вход: N (uint64)
    |
    v
[N < 0xFD ?] ── да ──> [вывести: uint8(N)] ──> [Готово]
    |
   нет
    v
[N <= 0xFFFF ?] ── да ──> [вывести: 0xFD] -> [LE16(N)] ──> [Готово]
    |
   нет
    v
[N <= 0xFFFFFFFF ?] ── да ──> [вывести: 0xFE] -> [LE32(N)] ──> [Готово]
    |
   нет
    v
[вывести: 0xFF] -> [LE64(N)] ──> [Готово]


Каноничность на encode обеспечивается выбором минимально возможной ветки.

Схема (flowchart) декодирования (с проверками каноничности)
[Старт] вход: bytes[cursor..]
    |
    v
[читать 1 байт -> x]
    |
    +-- x < 0xFD ----> [N = x] -> [ok, consumed=1]
    |
    +-- x == 0xFD --> [читать 2 байта LE16 -> N]
    |                   [если N < 0xFD -> error_noncanonical]
    |                   [ok, consumed=3]
    |
    +-- x == 0xFE --> [читать 4 байта LE32 -> N]
    |                   [если N < 0x10000 -> error_noncanonical]
    |                   [ok, consumed=5]
    |
    +-- x == 0xFF --> [читать 8 байт LE64 -> N]
                        [если N < 0x1_0000_0000 -> error_noncanonical]
                        [ok, consumed=9]


Плюс проверять EOF/недостаток байт на каждой ветке.

Псевдокод

encode

if N < 0xFD:
    out <- [N]
elif N <= 0xFFFF:
    out <- [0xFD] + LE16(N)
elif N <= 0xFFFFFFFF:
    out <- [0xFE] + LE32(N)
else:
    out <- [0xFF] + LE64(N)


decode

x = read_u8()
if x < 0xFD:
    return x, 1
elif x == 0xFD:
    n = read_le16()
    if n < 0xFD: error_noncanonical
    return n, 3
elif x == 0xFE:
    n = read_le32()
    if n < 0x10000: error_noncanonical
    return n, 5
else: # x == 0xFF
    n = read_le64()
    if n < 0x1_0000_0000: error_noncanonical
    return n, 9


оценка длины

encoded_len(N) =
  1  если N < 0xFD
  3  если N <= 0xFFFF
  5  если N <= 0xFFFFFFFF
  9  иначе

Тест-кейсы (encode → hex)

0 → 00

1 → 01

252 → fc

253 → fdfd00

254 → fdfe00

255 → fdff00

256 → fd0001

515 → fd0302 (0x0203 → LE = 03 02)

65535 → fdffff

65536 → fe00000100

70000 → fe70110100

4294967295 → feffffffff

4294967296 → ff0000000001000000

2^64−1 → ffffffffffffffffff (9 байт: FF + 8×FF)

Негатив (encode не должен так делать, decode должен отклонять как неканоничное):

252 как fdfc00 → error_noncanonical

65535 как feffff0000 → error_noncanonical

4294967295 как ffffffffff00000000 → error_noncanonical

Тест-кейсы (decode hex → (value, consumed))

00 → (0, 1)

fc → (252, 1)

fdfd00 → (253, 3)

fd0001 → (256, 3)

fdffff → (65535, 3)

fe00000100 → (65536, 5)

feffffffff → (4294967295, 5)

ff0000000001000000 → (4294967296, 9)

ffffffffffffffffff → (18446744073709551615, 9)

Негатив (decode → ошибка):

fdfc00 → noncanonical (значение 252 должно быть 1-байтовым)

feffff0000 → noncanonical (значение 65535 должно быть 3-байтовым)

ffffffffff00000000 → noncanonical (значение 4294967295 должно быть 5-байтовым)

fd / fd05 / fe0001 / ff00...(неполные) → EOF/underflow (недостаточно байт)

«Длина + данные» (типовой шаблон)

data = 01 02 03
len = 3 → заголовок 03 → итог: 03 01 02 03

data = <253 байта>
len = 253 → заголовок fd fd 00 → итог: fdfd00 || <253 байт>

len = 65536 → заголовок fe 00 00 01 00 → итог: fe00000100 || <65536 байт>

Всегда проверяй верхний лимит len на декодировании перед аллокацией буфера (защита от DoS).
---

## День 3 — **VOUT (TxOut)**: сериализация/парсинг (по байтам)

**Что делаем**
Собрать/разобрать один выход транзакции.

**Порядок байтов**

|  Шаг | Поле               |  Длина | Endianness  | Что кладём     |
| ---: | ------------------ | -----: | ----------- | -------------- |
| 0001 | `value`            |      8 | **u64 LE**  | сумма в сатоши |
| 0002 | `scriptPubKey_len` | VarInt | CompactSize | длина скрипта  |
| 0003 | `scriptPubKey`     |  `len` | как есть    | байты скрипта  |

**Тест-кейс (P2PKH)**

* `value=5000` → **u64 LE**: `88 13 00 00 00 00 00 00`
* `scriptPubKey = 76 a9 14 <20B> 88 ac`, `<20B>=00112233445566778899aabbccddeeff00112233`
  Ожидаемый **VOUT**:

```
88 13 00 00 00 00 00 00
19
76 a9 14 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff 00 11 22 33 88 ac
```

Слитно:
`88130000000000001976a91400112233445566778899aabbccddeeff0011223388ac`

---

## День 4 — **VIN (TxIn)**: сериализация/парсинг (по байтам)

**Что делаем**
Собрать/разобрать вход (общий случай). Подготовить `prev_txid` к **внутреннему порядку** (реверс байтов от explorer-вида).

**Порядок байтов**

|  Шаг | Поле            |  Длина | Endianness                | Что кладём           |
| ---: | --------------- | -----: | ------------------------- | -------------------- |
| 0001 | `prev_txid`     |     32 | **hash (внутр. порядок)** | 32B хэша источника   |
| 0002 | `prev_vout`     |      4 | **u32 LE**                | индекс выхода        |
| 0003 | `scriptSig_len` | VarInt | CompactSize               | длина                |
| 0004 | `scriptSig`     |  `len` | как есть                  | байты скрипта        |
| 0005 | `sequence`      |      4 | **u32 LE**                | обычно `ff ff ff ff` |

**Тест-кейс**
Исходные:

* `prev_txid (explorer)` = `000102...1e1f`
* `prev_vout=1`, `scriptSig=abcd`, `sequence=ffffffff`
  Ожидаемый **VIN**:

```
1f1e1d1c1b1a191817161514131211100f0e0d0c0b0a09080706050403020100
01 00 00 00
02
ab cd
ff ff ff ff
```

---

## День 5 — **Legacy-TX** и **TXID**

**Что делаем**
Сериализовать legacy-форму (без marker/flag/witness). Посчитать **TXID = dSHA256(legacy-байтов)**.

**Порядок байтов (Legacy-TX)**

|  Шаг | Поле         |  Длина | Endianness  |
| ---: | ------------ | -----: | ----------- |
| 0001 | `version`    |      4 | **i32 LE**  |
| 0002 | `vin_count`  | VarInt | CompactSize |
| 0003 | `vin[]`      | перем. | см. День 4  |
| 0004 | `vout_count` | VarInt | CompactSize |
| 0005 | `vout[]`     | перем. | см. День 3  |
| 0006 | `locktime`   |      4 | **u32 LE**  |

**Тест-кейс (1 vin + 1 vout)**
Ожидаемый **TX (legacy)**:

```
02 00 00 00
01
<VIN из Дня 4>
01
<VOUT из Дня 3>
00 00 00 00
```

Ожидаемый **TXID** (dSHA256 legacy-формы, «raw bytes»):
`5cf4de61446b227e1cc37f623262fe083790f7f4d846666caf26a466f5911b37`

---

## День 6 — **Witness (per-vin)**

**Что делаем**
Сериализовать/разобрать стек свидетеля каждого `vin`: `count` → (`len_i` → `item_i`)*.

**Порядок байтов**

|  Шаг | Поле                |  Длина | Endianness  |
| ---: | ------------------- | -----: | ----------- |
| 0001 | `stack_items_count` | VarInt | CompactSize |
| 0002 | `item_len[0]`       | VarInt | CompactSize |
| 0003 | `item[0]`           |  `len` | как есть    |
|    … | …                   |      … | …           |

**Тест-кейс**
Два элемента: `304402203456` и `03aa` →
`02 06 30 44 02 20 34 56 02 03 aa`
Слитно: `02063044022034560203aa`
Негатив: у vin без свидетеля `stack_items_count = 00`.

---

## День 7 — **SegWit-TX** и **WTXID** (и TXID от stripped-формы)

**Что делаем**
Сериализовать SegWit-форму (`marker=00`, `flag=01`), посчитать **WTXID** как dSHA256 полной формы. **TXID** — dSHA256 legacy-формы (без marker/flag/witness).

**Порядок байтов (SegWit-TX)**

|  Шаг | Поле              | Длина/значение | Endianness  |
| ---: | ----------------- | -------------- | ----------- |
| 0001 | `version`         | 4              | **i32 LE**  |
| 0002 | `marker`          | `00`           | —           |
| 0003 | `flag`            | `01`           | —           |
| 0004 | `vin_count`       | VarInt         | CompactSize |
| 0005 | `vin[]`           | перем.         | как в Дне 4 |
| 0006 | `vout_count`      | VarInt         | CompactSize |
| 0007 | `vout[]`          | перем.         | как в Дне 3 |
| 0008 | `witness per-vin` | перем.         | как в Дне 6 |
| 0009 | `locktime`        | 4              | **u32 LE**  |

**Тест-кейс**

* VIN0: как в Дне 4, но `scriptSig_len=00`, `sequence=feffffff`
* Witness(VIN0): из Дня 6
  Ожидаемые хэши:
* **TXID**:  `969e33d79d3c8cbc5ce7433dcd5559d0c5d8257deb1d0882abb030f76d869bf1`
* **WTXID**: `6e80bb419939753f9a4d6c6e54aaf04e133c32c4e501e6c1fa2370df06270652`

---

## День 8 — **Coinbase VIN (BIP34)**: минимальная LE-форма высоты

**Что делаем**
Сериализовать специальный вход coinbase: нулевой outpoint; **в начале `scriptSig`** — push **минимально закодированной** высоты (Script Number, **LE**).

**Порядок байтов (coinbase-vin)**

|  Шаг | Поле            |  Длина | Endianness/значение                |
| ---: | --------------- | -----: | ---------------------------------- |
| 0001 | `prev_txid`     |     32 | `00…00`                            |
| 0002 | `prev_vout`     |      4 | **u32 LE = ffffffff**              |
| 0003 | `scriptSig_len` | VarInt | CompactSize                        |
| 0004 | `scriptSig`     |  `len` | как есть; **в начале** push высоты |
| 0005 | `sequence`      |      4 | **u32 LE**                         |

**Тест-кейс (высота 1000)**

* Минимальная LE-форма: `e8 03`, push: `02 e8 03`
* Полоска vin:

```
00…00 (32B)
ff ff ff ff
03
02 e8 03
ff ff ff ff
```

---

## День 9 — **Subsidy + Fees**: расчёт miner-выплаты в coinbase

**Что делаем**

* `block_subsidy(height)`: старт `50 BTC` (5_0000_0000 сат), каждые `210000` блоков делим на 2; после 64 халвингов — 0.
* `fees_total` = сумма комиссий выбранных tx.
* В одном из `vout` coinbase: `value = subsidy + fees_total` (**u64 LE**).

**Endianness**

| Поле               | Endianness      |
| ------------------ | --------------- |
| `value`            | **u64 LE**      |
| `scriptPubKey_len` | **CompactSize** |
| `scriptPubKey`     | как есть        |

**Тест-кейсы (`value` только)**

* `height=0`, `fees=0`: `5_0000_0000` → **LE**: `00 f2 05 2a 01 00 00 00`
* `height=210000`, `fees=1000`: `2_5000_1000` → **LE**: `e8 fc 02 95 00 00 00 00`
* `height=630000`, `fees=0`: `625_000_000` → **LE**: `40 be 40 25 00 00 00 00`

---

## День 10 — Подбор транзакций: получить **TXID[]** и **WTXID[]**

**Что делаем**
Для набора кандидатов сериализовать каждую tx:

* в блок — SegWit-форма при наличии witness-входов, иначе Legacy;
* для идентификаторов: **TXID** всегда от legacy-формы; **WTXID** — от полной формы (если нет witness — равен TXID).
  Сформировать списки `TXID[]` (для дерева в header) и `WTXID[]` (для коммитмента, см. ниже).

**Тест-кейс**

* Взять Legacy-TX из Дня 5 → ожидаемый **TXID**:
  `5cf4de61446b227e1cc37f623262fe083790f7f4d846666caf26a466f5911b37`
* Взять SegWit-TX из Дня 7 → ожидаемые:
  **TXID**=`969e...9bf1`, **WTXID**=`6e80...0652`
* Проверка: обнулите witness → WTXID должен совпасть с TXID.

---

## День 11 — **Merkle по TXID** (в header)

**Что делаем**
Построить дерево по **TXID[]** (coinbase первая), дублируя последний элемент при нечётном числе узлов. Результат — `merkle_root` в заголовок.

**Endianness**

| Элемент                | Endianness                 |   |                |
| ---------------------- | -------------------------- | - | -------------- |
| листья/узлы            | 32B **внутренний порядок** |   |                |
| конкатенации           | 32B                        |   | 32B (как есть) |
| `merkle_root` в header | 32B **внутренний порядок** |   |                |

**Тест-кейс (3 tx)**
Листья: `00…00`, `11…11`, `22…22` →
`merkle_root = 16c94d996b5f836f454a3e1f9be1df8ba65d708d54b8ae84f52122b9c856e928`

---

## День 12 — **Merkle по WTXID** (для commitment)

**Что делаем**
Построить дерево по **WTXID[]** (для coinbase использовать **32×`00`**). Получить `wtxid_merkle_root`.

**Endianness** — как в Дне 11.

**Тест-кейс (3 wtxid)**
`wtxid_coinbase=00…00`, `wtxid1=aa…aa`, `wtxid2=bb…bb` →
`wtxid_merkle_root = 189817958043f0a8f7cd46f35a1e860e11512e2f446ffdbe7ed41c4a44073a57`

---

## День 13 — **Coinbase witness-reserved** и **OP_RETURN commitment**

**Что делаем**
Если в блоке есть хотя бы одна segwit-tx:

* В witness coinbase-входа — **ровно 1 элемент** `reserved32` (часто нули).
* В один из `vout` coinbase — **OP_RETURN-скрипт**:
  `6a 24 aa21a9ed <32B commitment> [опц. данныe]`, где
  `commitment = dSHA256( wtxid_merkle_root || reserved32 )`.

**Endianness**

| Поле                            | Endianness      |
| ------------------------------- | --------------- |
| `stack_items_count`, `item_len` | **CompactSize** |
| `reserved32`                    | как есть        |
| `vout.value`                    | **u64 LE**      |
| `scriptPubKey_len`              | **CompactSize** |
| `scriptPubKey`                  | как есть        |

**Тест-кейсы**

* Witness coinbase: `01 20 00…00(32B)`
* При `wtxid_merkle_root = 1898…3a57`, `reserved32=00…00` →
  `commitment = 9d8bee623b888775e5e988e2d465ac107518e5e91a963f7f3648952d466d20f8`
* `vout` (value=0) с OP_RETURN:

```
00 00 00 00 00 00 00 00
26
6a 24 aa 21 a9 ed 9d 8b ee 62 3b 88 87 75 e5 e9 88 e2 d4 65 ac 10 75 18 e5 e9 1a 96 3f 7f 36 48 95 2d 46 6d 20 f8
```

---

## День 14 — **Заголовок блока (80B)**: заполнение и dSHA256(header)

**Что делаем**
Заполнить 80B header:
`version (i32 LE)`, `prev_block (hash, внутр. порядок)`, `merkle_root (hash, внутр. порядок)`,
`time (u32 LE)`, `nBits (u32 LE)`, `nonce (u32 LE)`. Посчитать `dSHA256(header)`.

**Поля и Endianness**

| Поле                       | Endianness                     |
| -------------------------- | ------------------------------ |
| `version`                  | **i32 LE**                     |
| `prev_block`               | **hash (внутр. порядок, 32B)** |
| `merkle_root`              | **hash (внутр. порядок, 32B)** |
| `time` / `nBits` / `nonce` | **u32 LE**                     |

**Тест-вектор**

* `version=1` → `01 00 00 00`
* `prev_block = 11…11` (32×`11`)
* `merkle_root = 16c94d99…6e928` (из Дня 11)
* `time = 100000000` → `00 e1 f5 05`
* `nBits = 0x1d00ffff` → `ff ff 00 1d`
* `nonce = 0` → `00 00 00 00`
  Ожидаемый **dSHA256(header)** (raw bytes):
  `72e50f34a7a71aacf1af6d7de58a37f64b0f4b854ad304a10f4640dc6bdb4895`

---
## День 15.1 — ПОДПИСАТЬ ТРАНЗАКЦИЮ СВОЮ RAW

## День 15 — `nBits → target` и сравнение с `block_hash` (PoW-порог)

**Что делаем**
Преобразовать `nBits` в 256-битный **target** и сравнить `block_hash = dSHA256(header)` как беззнаковое 256-бит число: **hash ≤ target**?

**Endianness**

| Значение                              | Endianness               |
| ------------------------------------- | ------------------------ |
| `nBits` в header                      | **u32 LE**               |
| интерпретация `nBits`                 | `(mantissa, exponent)`   |
| `target` и `block_hash` для сравнения | **big-endian 32B** числа |

**Тест-кейсы**

* `nBits=0x1d00ffff` → target:
  `00000000ffff0000000000000000000000000000000000000000000000000000`
* `nBits=0x181bc330` → target:
  `00000000000000001bc330000000000000000000000000000000000000000000`
* Для header из Дня 14 и `nonce=0` сравнение обычно **ложь** (хэш > target) — это корректно.

---

## День 16 — **Тело блока**: `tx_count` + последовательность транзакций

**Что делаем**
Записать `tx_count` (**CompactSize**) и транзакции **в порядке включения**: coinbase первая; для каждой — SegWit-или Legacy-форма по правилам Дней 5–7.

**Endianness**

| Поле       | Endianness                     |
| ---------- | ------------------------------ |
| `tx_count` | **CompactSize**                |
| каждая tx  | SegWit-или Legacy-сериализация |

**Тест-кейс**

* `tx_count=02` → `02`
* `tx[0]` — coinbase (Дни 8–9 и, при нужде, 13)
* `tx[1]` — SegWit-TX (День 7)
  Ожидаемо: поток = `02 || <coinbase_tx_bytes> || <segwit_tx_bytes>`
  Проверка: пересчитать **TXID[]**, собрать **merkle_root** (День 11) — совпадает с header.

---

## День 17 — Интегрированный блок-кандидат (валидность структуры)

**Что делаем**
Собрать полноценный блок: `header(80B) || body`. Проверить:

1. сериализации вин/вaут/tx;
2. **TXID/WTXID** всех tx;
3. **witness_merkle_root** и **commitment** (при наличии segwit);
4. **merkle_root** в header = корню по TXID;
5. `dSHA256(header)` считается и соответствует полям;
6. базовые политики: coinbase первая, счётчики (CompactSize) корректны.

**Endianness** — как в соответствующих днях.

**Тест-кейсы**

* Сверка всех контрольных хэшей на маленьком наборе (coinbase + одна segwit-tx).
* Сверка длин (`scriptSig_len`, `scriptPubKey_len`, `witness`-длины).

---

## День 18 — Негативы и края

**Что делаем**
Проверить ошибки и отказы:

* Неканоничный **CompactSize** (`252` как `fdfc00`) → ошибка.
* SegWit-TX имеет witness, но отсутствуют `marker/flag` → ошибка.
* Блок с segwit-tx, но **нет** `reserved32` в coinbase-witness и/или **нет** OP_RETURN-commitment → ошибка.
* Хэши записаны не во внутреннем порядке в потоках → несовпадение **TXID/Merkle**.
* **BIP34**: высота не в минимальной Script-форме → ошибка.

**Endianness** — придерживаться правил из Дней 2–13; намеренно нарушать их в негатив-тестах.

---

## День 19 — Варьирование полей для PoW: `nonce`, `time`, extra-nonce

**Что делаем**
Продемонстрировать корректные «ручки» для изменения `block_hash`:

* перебирать `nonce` (**u32 LE**);
* если исчерпан — обновить `time` (**u32 LE**);
* изменить **extra-nonce** внутри coinbase `scriptSig` (меняет coinbase-TXID → `merkle_root` → header).

**Тест-кейсы**

* Сменить `nonce` → меняется `dSHA256(header)`; сравнить два разных значения.
* Сменить `time` → меняется `dSHA256(header)` и header-байты по смещению `[68..71]`.
* Сменить extra-nonce в coinbase → меняется **меркль-корень** (проверяем пересчётом по TXID).

---

## День 20 — Финальный smoke-test «готов к майнингу»

**Что делаем**
Имитировать полный цикл на фиксированном шаблоне:

1. взять `prev_block`, `height`, `nBits`, окно `time`;
2. собрать coinbase с **subsidy+fees** и (если нужно) **commitment**;
3. выбрать транзакции, посчитать **TXID/WTXID** и оба дерева;
4. сформировать `header`, убедиться в валидности всех связей;
5. проверить условие PoW (`hash ≤ target`) для пары десятков `nonce` (ожидаемо — нет решения, но логика сравнения верна).

**Критерии прохождения**

* Все тесты из Дней 1–19 зелёные.
* Любой пересчёт мерклей и хэшей по «сырью» даёт те же значения.

---

### Короткая сводка Endianness по проекту

* **Все целые** в потоках (version, time, nBits, nonce, value, sequence, prev_vout, locktime, счётчики внутри CompactSize) → **Little-Endian (LE)**.
* **Все 32-байтовые хэши** (prev_block, merkle_root, `prev_txid` в vin, листья и узлы мерклей) в потоках → **внутренний порядок (байты «перевёрнуты» относительно explorer-строк)**.
* **CompactSize/VarInt** — префиксный байт + значение в **LE** по правилам Дня 2.
* **Сравнение с target** в PoW — интерпретируем `block_hash` и `target` как **big-endian 32B** числа.

---

Скопируй этот файл как рабочий чек-лист. Идём день за днём: **сделал → запускаешь тесты → фиксируешь зелёный статус**.
